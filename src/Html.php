<?php

declare(strict_types=1);

namespace Yiisoft\Html;

use Closure;
use InvalidArgumentException;
use JsonException;
use Traversable;
use ValueError;
use Yiisoft\Arrays\ArrayHelper;
use Yiisoft\Html\Tag\A;
use Yiisoft\Html\Tag\Button;
use Yiisoft\Html\Tag\CustomTag;
use Yiisoft\Html\Tag\Div;
use Yiisoft\Html\Tag\Img;
use Yiisoft\Html\Tag\Input;
use Yiisoft\Html\Tag\Label;
use Yiisoft\Html\Tag\Li;
use Yiisoft\Html\Tag\Link;
use Yiisoft\Html\Tag\Ol;
use Yiisoft\Html\Tag\P;
use Yiisoft\Html\Tag\Script;
use Yiisoft\Html\Tag\Select;
use Yiisoft\Html\Tag\Span;
use Yiisoft\Html\Tag\Style;
use Yiisoft\Html\Tag\Textarea;
use Yiisoft\Html\Tag\Ul;
use Yiisoft\Json\Json;

use function array_key_exists;
use function in_array;
use function is_array;
use function is_bool;
use function is_int;
use function strlen;

/**
 * Html provides a set of static methods for generating commonly used HTML tags.
 *
 * Nearly all of the methods in this class allow setting additional HTML attributes for the HTML tags they generate.
 * You can specify, for example, `class`, `style` or `id` for an HTML element using the `$options` parameter. See the
 * documentation of the {@see tag()} method for more details.
 *
 * @psalm-type HtmlOptions = array<string, mixed>&array{
 *   id?: string|null,
 *   class?: string[]|string|null,
 *   style?: array<string, string>|string|null,
 * }
 * @psalm-type InputHtmlOptions = HtmlOptions&array {
 *   value?: string|int|float|\Stringable|bool|null,
 *   disabled?: bool,
 * }
 * @psalm-type BooleanInputHtmlOptions = InputHtmlOptions&array{
 *   label?: string|null,
 *   labelOptions?: HtmlOptions|null,
 *   wrapInput?: bool,
 *   uncheck?: string|int|float|\Stringable|bool|null,
 *   form?: string|null,
 * }
 * @psalm-type HtmlAttributes = array<string, mixed>&array{
 *   id?: string|\Stringable|null,
 *   class?: string[]|string|\Stringable[]|\Stringable|null,
 *   data?: array<array-key, array|string|\Stringable|null>|string|\Stringable|null,
 *   data-ng?: array<array-key, array|string|\Stringable|null>|string|\Stringable|null,
 *   ng?: array<array-key, array|string|\Stringable|null>|string|\Stringable|null,
 *   aria?: array<array-key, array|string|\Stringable|null>|string|\Stringable|null,
 * }
 */
final class Html
{
    /**
     * The preferred order of attributes in a tag. This mainly affects the order of the attributes that are
     * rendered by {@see renderTagAttributes()}.
     */
    private const ATTRIBUTE_ORDER = [
        'type',
        'id',
        'class',
        'name',
        'value',

        'href',
        'src',
        'srcset',
        'form',
        'action',
        'method',

        'selected',
        'checked',
        'readonly',
        'disabled',
        'multiple',

        'size',
        'maxlength',
        'width',
        'height',
        'rows',
        'cols',

        'alt',
        'title',
        'rel',
        'media',
    ];

    /**
     * List of tag attributes that should be specially handled when their values are of array type.
     * In particular, if the value of the `data` attribute is `['name' => 'xyz', 'age' => 13]`, two attributes will be
     * generated instead of one: `data-name="xyz" data-age="13"`.
     */
    private const DATA_ATTRIBUTES = ['data', 'data-ng', 'ng', 'aria'];

    /**
     * @var array
     * @psalm-var array<string, int>
     */
    private static array $generateIdCounter = [];

    /**
     * Returns an autogenerated sequential ID.
     *
     * @param string $prefix
     *
     * @return string Autogenerated ID.
     */
    public static function generateId(string $prefix = 'i'): string
    {
        $prefix .= hrtime(true);
        if (isset(self::$generateIdCounter[$prefix])) {
            $counter = ++self::$generateIdCounter[$prefix];
        } else {
            $counter = 1;
            self::$generateIdCounter = [$prefix => $counter];
        }
        return $prefix . $counter;
    }

    /**
     * Encodes special characters into HTML entities for use as a tag content
     * i.e. `<div>tag content</div>`.
     * Characters encoded are: &, <, >.
     *
     * @param mixed $content The content to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded content.
     *
     * @see https://html.spec.whatwg.org/#data-state
     */
    public static function encode($content, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        return htmlspecialchars(
            (string)$content,
            ENT_NOQUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );
    }

    /**
     * Encodes special characters into HTML entities for use as HTML tag unquoted attribute value
     * i.e. `<input value=my-value>`.
     * Characters encoded are: &, <, >, ", ', `, =, tab, space, U+000A (form feed), U+0000 (null).
     *
     * @param mixed $value The attribute value to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded attribute value.
     *
     * @see https://html.spec.whatwg.org/#attribute-value-(unquoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
     */
    public static function encodeUnquotedAttribute($value, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        $value = htmlspecialchars(
            (string)$value,
            ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );

        return strtr($value, [
            "\t" => '&Tab;', // U+0009 CHARACTER TABULATION (tab)
            "\n" => '&NewLine;', // U+000A LINE FEED (LF)
            "\u{000c}" => '&#12;', // U+000C FORM FEED (FF)
            "\u{0000}" => '&#0;', // U+0000 NULL
            ' ' => '&#32;', // U+0020 SPACE
            '=' => '&equals;', // U+003D EQUALS SIGN (=)
            '`' => '&grave;', // U+0060 GRAVE ACCENT (`)
        ]);
    }

    /**
     * Encodes special characters into HTML entities for use as HTML tag quoted attribute value
     * i.e. `<input value="my-value">`.
     * Characters encoded are: &, <, >, ", ', U+0000 (null).
     *
     * @param mixed $value The attribute value to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded attribute value.
     *
     * @see https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
     */
    public static function encodeAttribute($value, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        $value = htmlspecialchars(
            (string)$value,
            ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );

        return strtr($value, [
            "\u{0000}" => '&#0;', // U+0000 NULL
        ]);
    }

    /**
     * Escape special characters for use as JavaScript string value in a `<script` tag:
     *
     * ```
     * <script type="text/javascript">
     *     window.myVar = "<?= Html::escapeJavaScriptStringValue($myVar) ?>";
     * </script>
     * ```
     *
     * @param mixed $value JavaScript string.
     *
     * @return string Escaped JavaScript string.
     */
    public static function escapeJavaScriptStringValue($value): string
    {
        return strtr((string)$value, [
            '/' => '\/',
            '"' => '\"',
            "'" => "\'",
            '\\' => '\\\\',
        ]);
    }

    /**
     * Generates a complete HTML tag.
     *
     * @see CustomTag
     *
     * @param string $name The tag name.
     *
     * @psalm-param non-empty-string $name
     */
    public static function tag(string $name): CustomTag
    {
        return CustomTag::name($name);
    }

    /**
     * Generates a start tag.
     *
     * @see self::endTag()
     *
     * @param string $name The tag name.
     * @param array $attributes The tag attributes in terms of name-value pairs.
     *
     * @psalm-param non-empty-string $name
     * @psalm-param HtmlAttributes|array<empty, empty> $attributes
     */
    public static function beginTag(string $name, array $attributes = []): string
    {
        return '<' . $name . self::renderTagAttributes($attributes) . '>';
    }

    /**
     * Generates an end tag.
     *
     * @see self::beginTag()
     *
     * @param string $name The tag name.
     *
     * @psalm-param non-empty-string $name
     */
    public static function endTag(string $name): string
    {
        return "</$name>";
    }

    /**
     * Generates a {@see Style} tag.
     *
     * @param string $content The style content.
     */
    public static function style(string $content = ''): Style
    {
        $tag = Style::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Generates a {@see Script} tag.
     *
     * @param string $content The script content.
     */
    public static function script(string $content = ''): Script
    {
        $tag = Script::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Generates a {@see Link} tag.
     *
     * @param string|null $url The destination of the link.
     */
    public static function link(?string $url = null): Link
    {
        $tag = Link::tag();
        return $url === null ? $tag : $tag->url($url);
    }

    /**
     * Generates a {@see Link} tag that refers to an CSS file.
     *
     * @param string $url The URL of the CSS file.
     */
    public static function cssFile(string $url): Link
    {
        return Link::toCssFile($url);
    }

    /**
     * Generates a {@see Script} tag that refers to a JavaScript file.
     *
     * @param string $url The URL of the JavaScript file.
     */
    public static function javaScriptFile(string $url): Script
    {
        return Script::tag()->url($url);
    }

    public static function a(): A
    {
        return A::tag();
    }

    /**
     * Generates an {@see Img} tag.
     *
     * @param string $src The image URL.
     */
    public static function img(?string $url = null): Img
    {
        $tag = Img::tag();
        return $url === null ? $tag : $tag->src($url);
    }

    /**
     * Generates a {@see Label} tag.
     *
     * @param string $content Label text.
     * @param string|null $for The ID of the HTML element that this label is associated with.
     * If this is null, the "for" attribute will not be generated.
     */
    public static function label(string $content = '', ?string $for = null): Label
    {
        $tag = Label::tag();
        if ($for !== null) {
            $tag = $tag->forId($for);
        }
        if ($content !== '') {
            $tag = $tag->content($content);
        }
        return $tag;
    }

    /**
     * Generates a button tag.
     *
     * @see Button::button()
     *
     * @param string $content The content enclosed within the button tag.
     */
    public static function button(string $content = 'Button'): Button
    {
        return Button::button($content);
    }

    /**
     * Generates a submit button tag.
     *
     * @see Button::submit()
     *
     * @param string $content The content enclosed within the button tag.
     */
    public static function submitButton(string $content = 'Submit'): Button
    {
        return Button::submit($content);
    }

    /**
     * Generates a reset button tag.
     *
     * @see Button::reset()
     *
     * @param string $content The content enclosed within the button tag.
     */
    public static function resetButton(string $content = 'Reset'): Button
    {
        return Button::reset($content);
    }

    /**
     * Generates an {@see Input} type of the given type.
     *
     * @param string $type The type attribute.
     * @param string|null $name The name attribute. If it is `null`, the name attribute will not be generated.
     * @param \Stringable|string|int|float|bool|null $value The value attribute. If it is `null`, the value
     * attribute will not be generated.
     */
    public static function input(string $type, ?string $name = null, $value = null): Input
    {
        $tag = Input::tag()->type($type);
        if ($name !== null) {
            $tag = $tag->name($name);
        }
        if ($value !== null) {
            $tag = $tag->value($value);
        }
        return $tag;
    }

    /**
     * Generates an {@see Input} button.
     *
     * @see Input::button()
     *
     * @param string|null $label The value attribute.
     */
    public static function buttonInput(?string $label = 'Button'): Input
    {
        return Input::button($label);
    }

    /**
     * Generates a submit {@see Input} button.
     *
     * @see Input::submitButton()
     *
     * @param string|null $label The value attribute.
     */
    public static function submitInput(?string $label = 'Submit'): Input
    {
        return Input::submitButton($label);
    }

    /**
     * Generates a reset {@see Input} button.
     *
     * @see Input::resetButton()
     *
     * @param string|null $label The value attribute.
     */
    public static function resetInput(?string $label = 'Reset'): Input
    {
        return Input::resetButton($label);
    }

    /**
     * Generates a text {@see Input} field.
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function textInput(?string $name = null, $value = null): Input
    {
        return Input::text($name, $value);
    }

    /**
     * Generates a hidden input field.
     *
     * @see Input::hidden()
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function hiddenInput(?string $name = null, $value = null): Input
    {
        return Input::hidden($name, $value);
    }

    /**
     * Generates a password input field.
     *
     * @see Input::password()
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function passwordInput(?string $name = null, $value = null): Input
    {
        return Input::password($name, $value);
    }

    /**
     * Generates a file input field.
     *
     * To use a file input field, you should set the enclosing form's "enctype" attribute to be "multipart/form-data".
     * After the form is submitted, the uploaded file information can be obtained via $_FILES[$name]
     * (see PHP documentation).
     *
     * @see Input::file()
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function fileInput(?string $name = null, $value = null): Input
    {
        return Input::file($name, $value);
    }

    /**
     * Generates a radio button {@see Input}.
     *
     * @see Input::radio()
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function radioInput(?string $name = null, $value = null): Input
    {
        return Input::radio($name, $value);
    }

    /**
     * Generates a checkbox {@see Input}.
     *
     * @see Input::checkbox()
     *
     * @param string|null $name The name attribute.
     * @param \Stringable|string|int|float|bool|null $value The value attribute.
     */
    public static function checkboxInput(?string $name = null, $value = null): Input
    {
        return Input::checkbox($name, $value);
    }

    /**
     * Generates a {@see Textarea} input.
     *
     * @param string|null $name The input name.
     * @param string|null $value The input value.
     */
    public static function textarea(?string $name = null, ?string $value = null): Textarea
    {
        $tag = Textarea::tag();
        if ($name !== null) {
            $tag = $tag->name($name);
        }
        if (!empty($value)) {
            $tag = $tag->value($value);
        }
        return $tag;
    }

    /**
     * Generates a radio button input.
     *
     * @param string $name The name attribute.
     * @param bool $checked Whether the radio button should be checked.
     * @param array $options The tag options in terms of name-value pairs.
     * See {@see booleanInput()} for details about accepted attributes.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated radio button tag.
     */
    public static function radio(string $name, bool $checked = false, array $options = []): string
    {
        return self::booleanInput('radio', $name, $checked, $options);
    }

    /**
     * Generates a checkbox input.
     *
     * @param string $name The name attribute.
     * @param bool $checked Whether the checkbox should be checked.
     * @param array $options The tag options in terms of name-value pairs.
     * See {@see booleanInput()} for details about accepted attributes.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox tag.
     */
    public static function checkbox(string $name, bool $checked = false, array $options = []): string
    {
        return self::booleanInput('checkbox', $name, $checked, $options);
    }

    /**
     * Generates a boolean input.
     *
     * @param string $type The input type. This can be either `radio` or `checkbox`.
     * @param string $name The name attribute.
     * @param bool $checked Whether the checkbox should be checked.
     * @param array $options The tag options in terms of name-value pairs. The following options are specially handled:
     *
     * - uncheck: string, the value associated with the uncheck state of the checkbox. When this attribute is present,
     *   a hidden input will be generated so that if the checkbox is not checked and is submitted, the value of this
     *   attribute will still be submitted to the server via the hidden input.
     * - label: string, a label displayed next to the checkbox. It will NOT be HTML-encoded. Therefore you can pass in
     *   HTML code such as an image tag. If this is is coming from end users, you should {@see encode()}
     *   it to prevent XSS attacks.
     *   When this option is specified, the checkbox will be enclosed by a label tag.
     * - labelOptions: array, the HTML attributes for the label tag. Do not set this option unless you set the "label"
     *   option.
     * - wrapInput: bool, use when has label.
     *   if `wrapInput` is true result will be `<label><input> Label</label>`,
     *   else `<input> <label>Label</label>`
     *
     * The rest of the options will be rendered as the attributes of the resulting checkbox tag. The values will be
     * HTML-encoded using {@see encodeAttribute()}. If a value is null, the corresponding attribute will not be
     * rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox tag.
     */
    private static function booleanInput(string $type, string $name, bool $checked, array $options): string
    {
        $options['checked'] = $checked;
        $value = array_key_exists('value', $options) ? $options['value'] : '1';

        if (isset($options['uncheck'])) {
            // Add a hidden field so that if the checkbox is not selected, it still submits a value.
            $hiddenOptions = [];
            if (isset($options['form'])) {
                $hiddenOptions['form'] = $options['form'];
            }
            // Make sure disabled input is not sending any value.
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput(
                $name,
                isset($options['uncheck']) ? (string)$options['uncheck'] : null
            )->attributes($hiddenOptions);

            unset($options['uncheck']);
        } else {
            $hidden = '';
        }

        $label = $options['label'] ?? null;
        $labelOptions = $options['labelOptions'] ?? [];
        $wrapInput = $options['wrapInput'] ?? true;
        unset($options['label'], $options['labelOptions'], $options['wrapInput']);

        if (empty($label)) {
            return $hidden . self::input($type, $name, $value)->attributes($options);
        }

        if ($wrapInput) {
            $input = self::input($type, $name, $value)->attributes($options);
            return $hidden . self::label($input . ' ' . $label, null)->attributes($labelOptions)->withoutEncode();
        }

        if (!isset($options['id'])) {
            $options['id'] = self::generateId();
        }
        return $hidden .
            self::input($type, $name, $value)->attributes($options) .
            ' ' .
            self::label($label, $options['id'])->attributes($labelOptions);
    }

    /**
     * Generates a {@see Select} tag.
     *
     * @param string|null $name The name attribute
     */
    public static function select(?string $name = null): Select
    {
        $tag = Select::tag();
        if ($name !== null) {
            $tag = $tag->name($name);
        }
        return $tag;
    }

    /**
     * Generates a list of checkboxes.
     *
     * A checkbox list allows multiple selection, like {@see listBox()}. As a result, the corresponding submitted value
     * is an array.
     *
     * @param string $name The name attribute of each checkbox.
     * @param array|bool|float|int|string|Traversable|null $selection The selected value(s). String for single or array
     * for multiple selection(s).
     * @param array $items The data item used to generate the checkboxes. The array keys are the checkbox values, while
     * the array values are the corresponding labels.
     * @param array $options Options (name => config) for the checkbox list container tag. The following options are
     * specially handled:
     *
     * - tag: string|false, the tag name of the container element. False to render checkbox without container.
     *   See also {@see tag()}.
     * - unselect: string, the value that should be submitted when none of the checkboxes is selected. By setting this
     *   option, a hidden input will be generated.
     * - encode: boolean, whether to HTML-encode the checkbox labels. Defaults to true. This option is ignored if `item`
     *   option is set.
     * - separator: string, the HTML code that separates items.
     * - itemOptions: array, the options for generating the checkbox tag using {@see checkbox()}.
     * - item: callable, a callback that can be used to customize the generation of the HTML code corresponding to a
     *   single item in $items. The signature of this callback must be:
     *
     *   ```php
     *   function ($index, $label, $name, $checked, $value)
     *   ```
     *
     *   where $index is the zero-based index of the checkbox in the whole list; $label is the label for the checkbox;
     *   and $name, $value and $checked represent the name, value and the checked status of the checkbox input,
     *   respectively.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|\Stringable|int|float|bool|null $selection
     * @psalm-param array<array-key, string> $items
     * @psalm-param InputHtmlOptions&array{
     *   item?: Closure(int, string, string, bool, mixed):string|null,
     *   itemOptions?: HtmlOptions|null,
     *   encode?: bool,
     *   separator?: string|null,
     *   tag?: string|null,
     *   unselect?: string|int|float|\Stringable|bool|null,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox list.
     */
    public static function checkboxList(string $name, $selection = null, array $items = [], array $options = []): string
    {
        $name = self::getArrayableName($name);

        if (is_iterable($selection)) {
            $selection = array_map('\strval', is_array($selection) ? $selection : iterator_to_array($selection));
        } elseif ($selection !== null) {
            $selection = (string)$selection;
        }

        /** @var Closure(int, string, string, bool, mixed):string|null $formatter */
        $formatter = ArrayHelper::remove($options, 'item');

        /** @psalm-var HtmlOptions $itemOptions */
        $itemOptions = ArrayHelper::remove($options, 'itemOptions', []);

        /** @var bool $encode */
        $encode = ArrayHelper::remove($options, 'encode', true);

        /** @var string $separator */
        $separator = ArrayHelper::remove($options, 'separator', "\n");

        /** @psalm-var non-empty-string|false $tag */
        $tag = ArrayHelper::remove($options, 'tag', 'div');

        /** @psalm-var InputHtmlOptions&array{unselect?: string|int|float|\Stringable|bool|null} $options */

        $lines = [];
        $index = 0;
        foreach ($items as $value => $label) {
            $checked = $selection !== null &&
                ((!is_iterable($selection) && !strcmp((string)$value, $selection))
                    || (is_iterable($selection) && ArrayHelper::isIn((string)$value, $selection)));
            if ($formatter !== null) {
                $lines[] = $formatter($index, $label, $name, $checked, $value);
            } else {
                $lines[] = self::checkbox($name, $checked, array_merge([
                    'value' => $value,
                    'label' => $encode ? self::encode($label) : $label,
                ], $itemOptions));
            }
            $index++;
        }

        if (isset($options['unselect'])) {
            // Add a hidden field so that if the list box has no option being selected, it still submits a value.
            $name2 = self::getNonArrayableName($name);
            $hiddenOptions = [];
            // Make sure disabled input is not sending any value.
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput(
                $name2,
                isset($options['unselect']) ? (string)$options['unselect'] : null
            )->attributes($hiddenOptions);
            unset($options['unselect'], $options['disabled']);
        } else {
            $hidden = '';
        }

        $visibleContent = implode($separator, $lines);
        return $hidden . (
            $tag === false
                ? $visibleContent
                : self::tag($tag)->content($visibleContent)->attributes($options)->withoutEncode()
            );
    }

    /**
     * Generates a list of radio buttons.
     *
     * A radio button list is like a checkbox list, except that it only allows single selection.
     *
     * @param string $name The name attribute of each radio button.
     * @param array|bool|float|int|string|Traversable|null $selection The selected value(s). String for single or array
     * for multiple selection(s).
     * @param array $items The data item used to generate the radio buttons. The array keys are the radio button
     * values, while the array values are the corresponding labels.
     * @param array $options Options (name => config) for the radio button list container tag. The following options
     * are specially handled:
     *
     * - tag: string|false, the tag name of the container element. False to render radio buttons without container.
     *   See also {@see tag()}.
     * - unselect: string, the value that should be submitted when none of the radio buttons is selected. By setting
     *   this option, a hidden input will be generated.
     * - encode: boolean, whether to HTML-encode the checkbox labels. Defaults to true. This option is ignored if `item`
     *   option is set.
     * - separator: string, the HTML code that separates items.
     * - itemOptions: array, the options for generating the radio button tag using {@see radio()}.
     * - item: callable, a callback that can be used to customize the generation of the HTML code corresponding to a
     *   single item in $items. The signature of this callback must be:
     *
     *   ```php
     *   function ($index, $label, $name, $checked, $value)
     *   ```
     *
     *   where $index is the zero-based index of the radio button in the whole list; $label is the label for the radio
     *   button; and $name, $value and $checked represent the name, value and the checked status of the radio button
     *   input, respectively.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|\Stringable|int|float|bool|null $selection
     * @psalm-param array<array-key, string> $items
     * @psalm-param InputHtmlOptions&array{
     *   item?: Closure(int, string, string, bool, mixed):string|null,
     *   itemOptions?: HtmlOptions|null,
     *   encode?: bool,
     *   separator?: string|null,
     *   tag?: string|null,
     *   unselect?: string|int|float|\Stringable|bool|null,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated radio button list.
     */
    public static function radioList(string $name, $selection = null, array $items = [], array $options = []): string
    {
        if (is_iterable($selection)) {
            $selection = array_map('strval', is_array($selection) ? $selection : iterator_to_array($selection));
        } elseif ($selection !== null) {
            $selection = (string)$selection;
        }

        /** @var Closure(int, string, string, bool, mixed):string|null $formatter */
        $formatter = ArrayHelper::remove($options, 'item');

        /** @psalm-var HtmlOptions $itemOptions */
        $itemOptions = ArrayHelper::remove($options, 'itemOptions', []);

        /** @var bool $encode */
        $encode = ArrayHelper::remove($options, 'encode', true);

        /** @var string $separator */
        $separator = ArrayHelper::remove($options, 'separator', "\n");

        /** @psalm-var non-empty-string|false $tag */
        $tag = ArrayHelper::remove($options, 'tag', 'div');

        /** @psalm-var InputHtmlOptions&array{unselect?: string|int|float|\Stringable|bool|null} $options */

        $hidden = '';
        if (isset($options['unselect'])) {
            // add a hidden field so that if the list box has no option being selected, it still submits a value
            $hiddenOptions = [];
            // make sure disabled input is not sending any value
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput(
                $name,
                isset($options['unselect']) ? (string)$options['unselect'] : null
            )->attributes($hiddenOptions);

            unset($options['unselect'], $options['disabled']);
        }

        $lines = [];
        $index = 0;
        foreach ($items as $value => $label) {
            $checked = $selection !== null &&
                ((!is_iterable($selection) && !strcmp((string)$value, $selection))
                    || (is_iterable($selection) && ArrayHelper::isIn((string)$value, $selection)));
            if ($formatter !== null) {
                $lines[] = $formatter($index, $label, $name, $checked, $value);
            } else {
                $lines[] = self::radio($name, $checked, array_merge([
                    'value' => $value,
                    'label' => $encode ? self::encode($label) : $label,
                ], $itemOptions));
            }
            $index++;
        }
        $visibleContent = implode($separator, $lines);

        return $hidden . (
            $tag === false
                ? $visibleContent
                : self::tag($tag)->content($visibleContent)->attributes($options)->withoutEncode()
            );
    }

    /**
     * Generates a {@see Div} tag.
     *
     * @param string $content Tag content.
     */
    public static function div(string $content = ''): Div
    {
        $tag = Div::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Generates a {@see Span} tag.
     *
     * @param string $content Tag content.
     */
    public static function span(string $content = ''): Span
    {
        $tag = Span::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Generates a {@see P} tag.
     *
     * @param string $content Tag content.
     */
    public static function p(string $content = ''): P
    {
        $tag = P::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Generates a {@see Ul} tag.
     */
    public static function ul(): Ul
    {
        return Ul::tag();
    }

    /**
     * Generates a {@see Ol} tag.
     */
    public static function ol(): Ol
    {
        return Ol::tag();
    }

    /**
     * Generates a {@see Li} tag.
     *
     * @param string $content Tag content.
     */
    public static function li(string $content = ''): Li
    {
        $tag = Li::tag();
        return empty($content) ? $tag : $tag->content($content);
    }

    /**
     * Renders the HTML tag attributes.
     *
     * Attributes whose values are of boolean type will be treated as
     * [boolean attributes](http://www.w3.org/TR/html5/infrastructure.html#boolean-attributes).
     *
     * Attributes whose values are null will not be rendered. The values of attributes will be HTML-encoded using
     * {@see encodeAttribute()}.
     *
     * The "data" attribute is specially handled when it is receiving an array value. In this case, the array will be
     * "expanded" and a list data attributes will be rendered. For example, if `'data' => ['id' => 1, 'name' => 'yii']`
     * then this will be rendered `data-id="1" data-name="yii"`.
     *
     * Additionally `'data' => ['params' => ['id' => 1, 'name' => 'yii'], 'status' => 'ok']` will be rendered as:
     * `data-params='{"id":1,"name":"yii"}' data-status="ok"`.
     *
     * @param array $attributes Attributes to be rendered. The attribute values will be HTML-encoded using
     * {@see encodeAttribute()}.
     *
     * @psalm-param HtmlAttributes|array<empty, empty> $attributes
     *
     * @throws JsonException
     *
     * @return string The rendering result. If the attributes are not empty, they will be rendered into a string
     * with a leading white space (so that it can be directly appended to the tag name in a tag). If there is no
     * attribute, an empty string will be returned.
     */
    public static function renderTagAttributes(array $attributes): string
    {
        if (count($attributes) > 1) {
            $sorted = [];
            foreach (self::ATTRIBUTE_ORDER as $name) {
                if (isset($attributes[$name])) {
                    /** @var mixed */
                    $sorted[$name] = $attributes[$name];
                }
            }
            $attributes = array_merge($sorted, $attributes);
        }

        $html = '';
        /** @var mixed $value */
        foreach ($attributes as $name => $value) {
            if (is_bool($value)) {
                if ($value) {
                    $html .= " $name";
                }
            } elseif (is_array($value)) {
                if (in_array($name, self::DATA_ATTRIBUTES, true)) {
                    /** @psalm-var array<array-key, array|string|\Stringable|null> $value */
                    foreach ($value as $n => $v) {
                        if (is_array($v)) {
                            $html .= " $name-$n='" . Json::htmlEncode($v) . "'";
                        } else {
                            $html .= " $name-$n=\"" . self::encodeAttribute($v) . '"';
                        }
                    }
                } elseif ($name === 'class') {
                    if (empty($value)) {
                        continue;
                    }
                    $html .= " $name=\"" . self::encodeAttribute(implode(' ', $value)) . '"';
                } elseif ($name === 'style') {
                    if (empty($value)) {
                        continue;
                    }
                    /** @psalm-var array<string, string> $value */
                    $html .= " $name=\"" . self::encodeAttribute(self::cssStyleFromArray($value)) . '"';
                } else {
                    $html .= " $name='" . Json::htmlEncode($value) . "'";
                }
            } elseif ($value !== null) {
                $html .= " $name=\"" . self::encodeAttribute($value) . '"';
            }
        }

        return $html;
    }

    /**
     * Adds a CSS class (or several classes) to the specified options.
     *
     * If the CSS class is already in the options, it will not be added again. If class specification at given options
     * is an array, and some class placed there with the named (string) key, overriding of such key will have no
     * effect. For example:
     *
     * ```php
     * $options = ['class' => ['persistent' => 'initial']];
     *
     * // ['class' => ['persistent' => 'initial']];
     * Html::addCssClass($options, ['persistent' => 'override']);
     * ```
     *
     * @see removeCssClass()
     *
     * @param array $options The options to be modified.
     * @param string|string[] $class The CSS class(es) to be added.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function addCssClass(array &$options, $class): void
    {
        if (isset($options['class'])) {
            if (is_array($options['class'])) {
                $options['class'] = self::mergeCssClasses($options['class'], (array)$class);
            } else {
                $classes = preg_split('/\s+/', $options['class'], -1, PREG_SPLIT_NO_EMPTY);
                $options['class'] = implode(' ', self::mergeCssClasses($classes, (array)$class));
            }
        } else {
            $options['class'] = $class;
        }
    }

    /**
     * Removes a CSS class from the specified options.
     *
     * @see addCssClass()
     *
     * @param array $options The options to be modified.
     * @param string|string[] $class The CSS class(es) to be removed.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function removeCssClass(array &$options, $class): void
    {
        if (isset($options['class'])) {
            if (is_array($options['class'])) {
                $classes = array_diff($options['class'], (array)$class);
                if (empty($classes)) {
                    unset($options['class']);
                } else {
                    $options['class'] = $classes;
                }
            } else {
                $classes = preg_split('/\s+/', $options['class'], -1, PREG_SPLIT_NO_EMPTY);
                $classes = array_diff($classes, (array)$class);
                if (empty($classes)) {
                    unset($options['class']);
                } else {
                    $options['class'] = implode(' ', $classes);
                }
            }
        }
        /** @psalm-var HtmlOptions $options */
    }

    /**
     * Merges already existing CSS classes with new one.
     *
     * This method provides the priority for named existing classes over additional.
     *
     * @param string[] $existingClasses Already existing CSS classes.
     * @param string[] $additionalClasses CSS classes to be added.
     *
     * @return string[] merge result.
     */
    private static function mergeCssClasses(array $existingClasses, array $additionalClasses): array
    {
        foreach ($additionalClasses as $key => $class) {
            if (is_int($key) && !in_array($class, $existingClasses, true)) {
                $existingClasses[] = $class;
            } elseif (!isset($existingClasses[$key])) {
                $existingClasses[$key] = $class;
            }
        }

        return array_unique($existingClasses);
    }

    /**
     * Adds the specified CSS style to the HTML options.
     *
     * If the options already contain a `style` element, the new style will be merged
     * with the existing one. If a CSS property exists in both the new and the old styles,
     * the old one may be overwritten if `$overwrite` is true.
     *
     * For example,
     *
     * ```php
     * Html::addCssStyle($options, 'width: 100px; height: 200px');
     * ```
     *
     * @see removeCssStyle()
     *
     * @param array $options The HTML options to be modified.
     * @param array<string, string>|string $style The new style string (e.g. `'width: 100px; height: 200px'`) or array
     * (e.g. `['width' => '100px', 'height' => '200px']`).
     * @param bool $overwrite Whether to overwrite existing CSS properties if the new style contain them too.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function addCssStyle(array &$options, $style, bool $overwrite = true): void
    {
        if (!empty($options['style'])) {
            $oldStyle = is_array($options['style']) ? $options['style'] : self::cssStyleToArray($options['style']);
            $newStyle = is_array($style) ? $style : self::cssStyleToArray($style);
            if (!$overwrite) {
                foreach ($newStyle as $property => $value) {
                    if (isset($oldStyle[$property])) {
                        unset($newStyle[$property]);
                    }
                }
            }
            $style = array_merge($oldStyle, $newStyle);
        }
        $options['style'] = is_array($style) ? self::cssStyleFromArray($style) : $style;
    }

    /**
     * Removes the specified CSS style from the HTML options.
     *
     * For example,
     *
     * ```php
     * Html::removeCssStyle($options, ['width', 'height']);
     * ```
     *
     * @see addCssStyle()
     *
     * @param array $options The HTML options to be modified.
     * @param string|string[] $properties The CSS properties to be removed. You may use a string if you are removing a
     * single property.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function removeCssStyle(array &$options, $properties): void
    {
        if (!empty($options['style'])) {
            $style = is_array($options['style']) ? $options['style'] : self::cssStyleToArray($options['style']);
            foreach ((array)$properties as $property) {
                unset($style[$property]);
            }
            $options['style'] = self::cssStyleFromArray($style);
        }
    }

    /**
     * Converts a CSS style array into a string representation.
     *
     * For example,
     *
     * ```php
     * // width: 100px; height: 200px;
     * Html::cssStyleFromArray(['width' => '100px', 'height' => '200px']);
     * ```
     *
     * @see cssStyleToArray()
     *
     * @param array<string, string> $style The CSS style array. The array keys are the CSS property names,
     * and the array values are the corresponding CSS property values.
     *
     * @return string|null The CSS style string. If the CSS style is empty, a null will be returned.
     */
    public static function cssStyleFromArray(array $style): ?string
    {
        $result = '';
        foreach ($style as $name => $value) {
            $result .= "$name: $value; ";
        }

        // Return null if empty to avoid rendering the "style" attribute.
        return $result === '' ? null : rtrim($result);
    }

    /**
     * Converts a CSS style string into an array representation.
     *
     * The array keys are the CSS property names, and the array values are the corresponding CSS property values.
     *
     * For example,
     *
     * ```php
     * // ['width' => '100px', 'height' => '200px']
     * Html::cssStyleToArray('width: 100px; height: 200px;');
     * ```
     *
     * @see cssStyleFromArray()
     *
     * @param string $style The CSS style string.
     *
     * @return array The array representation of the CSS style.
     * @psalm-return array<string, string>
     */
    public static function cssStyleToArray(string $style): array
    {
        $result = [];
        foreach (explode(';', $style) as $property) {
            $property = explode(':', $property);
            if (count($property) > 1) {
                $result[trim($property[0])] = trim($property[1]);
            }
        }

        return $result;
    }

    /**
     * Normalize PCRE regular expression to use in the "pattern" HTML attribute:
     *  - convert \x{FFFF} to \uFFFF;
     *  - remove flags and delimiters.
     *
     * For example:
     *
     * ```php
     * Html::normalizeRegexpPattern('/([a-z0-9-]+)/im'); // will return: ([a-z0-9-]+)
     * ```
     *
     * @see https://html.spec.whatwg.org/multipage/input.html#the-pattern-attribute
     *
     * @param string $regexp PCRE regular expression.
     * @param string|null $delimiter Regular expression delimiter.
     *
     * @throws InvalidArgumentException if incorrect regular expression or delimiter
     *
     * @return string Value for use in the "pattern" HTML attribute
     */
    public static function normalizeRegexpPattern(string $regexp, ?string $delimiter = null): string
    {
        if (strlen($regexp) < 2) {
            throw new InvalidArgumentException('Incorrect regular expression.');
        }

        $pattern = preg_replace('/\\\\x{?([0-9a-fA-F]+)}?/', '\u$1', $regexp);

        if ($delimiter === null) {
            $delimiter = substr($pattern, 0, 1);
        } elseif (strlen($delimiter) !== 1) {
            throw new InvalidArgumentException('Incorrect delimiter.');
        }

        try {
            $endPosition = strrpos($pattern, $delimiter, 1);
        } catch (ValueError $e) { // For PHP 8
            $endPosition = false;
        }
        if ($endPosition === false) {
            throw new InvalidArgumentException('Incorrect regular expression.');
        }

        return substr($pattern, 1, $endPosition - 1);
    }

    private static function getArrayableName(string $name): string
    {
        return substr($name, -2) !== '[]' ? $name . '[]' : $name;
    }

    private static function getNonArrayableName(string $name): string
    {
        return substr($name, -2) === '[]' ? substr($name, 0, -2) : $name;
    }
}
