<?php

declare(strict_types=1);

namespace Yiisoft\Html;

use Closure;
use InvalidArgumentException;
use JsonException;
use Traversable;
use ValueError;
use Yiisoft\Arrays\ArrayHelper;
use Yiisoft\Json\Json;

use function array_key_exists;
use function in_array;
use function is_array;
use function is_bool;
use function is_int;
use function is_string;
use function strlen;

/**
 * Html provides a set of static methods for generating commonly used HTML tags.
 *
 * Nearly all of the methods in this class allow setting additional HTML attributes for the HTML tags they generate.
 * You can specify, for example, `class`, `style` or `id` for an HTML element using the `$options` parameter. See the
 * documentation of the {@see tag()} method for more details.
 *
 * @psalm-type HtmlOptions = array<string, mixed>&array{
 *   id?: string|null,
 *   class?: string[]|string|null,
 *   style?: array<string, string>|string|null,
 * }
 * @psalm-type ListHtmlOptions = HtmlOptions&array{
 *   tag?: string,
 *   encode?: bool,
 *   item?: Closure(string, array-key):string|null,
 *   separator?: string,
 *   itemOptions: HtmlOptions,
 * }
 * @psalm-type InputHtmlOptions = HtmlOptions&array {
 *   value?: string|int|float|\Stringable|bool|null,
 *   disabled?: bool,
 * }
 * @psalm-type BooleanInputHtmlOptions = InputHtmlOptions&array{
 *   label?: string|null,
 *   labelOptions?: HtmlOptions|null,
 *   wrapInput?: bool,
 *   uncheck?: string|int|float|\Stringable|bool|null,
 *   form?: string|null,
 * }
 * @psalm-type SelectHtmlOptions = HtmlOptions&array{
 *   encodeSpaces?: bool,
 *   encode?: bool,
 *   prompt?: array{
 *     text: string,
 *     options: HtmlOptions,
 *   }|string|null,
 *   options?: array<array-key, HtmlOptions>,
 *   groups?: array<array-key, HtmlOptions>,
 * }
 * @psalm-type ListBoxHtmlOptions = SelectHtmlOptions&array{
 *   size?: int,
 *   multiple?: bool,
 *   unselect?: string|int|float|\Stringable|bool|null,
 *   disabled?: bool,
 * }
 *
 * @psalm-type SelectItems = array<array-key, string[]|string>
 */
final class Html
{
    /**
     * List of void elements. These only have a start tag; end tags must not be specified.
     * {@see http://www.w3.org/TR/html-markup/syntax.html#void-element}
     */
    private const VOID_ELEMENTS = [
        'area' => 1,
        'base' => 1,
        'br' => 1,
        'col' => 1,
        'command' => 1,
        'embed' => 1,
        'hr' => 1,
        'img' => 1,
        'input' => 1,
        'keygen' => 1,
        'link' => 1,
        'meta' => 1,
        'param' => 1,
        'source' => 1,
        'track' => 1,
        'wbr' => 1,
    ];

    /**
     * The preferred order of attributes in a tag. This mainly affects the order of the attributes that are
     * rendered by {@see renderTagAttributes()}.
     */
    private const ATTRIBUTE_ORDER = [
        'type',
        'id',
        'class',
        'name',
        'value',

        'href',
        'src',
        'srcset',
        'form',
        'action',
        'method',

        'selected',
        'checked',
        'readonly',
        'disabled',
        'multiple',

        'size',
        'maxlength',
        'width',
        'height',
        'rows',
        'cols',

        'alt',
        'title',
        'rel',
        'media',
    ];

    /**
     * List of tag attributes that should be specially handled when their values are of array type.
     * In particular, if the value of the `data` attribute is `['name' => 'xyz', 'age' => 13]`, two attributes will be
     * generated instead of one: `data-name="xyz" data-age="13"`.
     */
    private const DATA_ATTRIBUTES = ['data', 'data-ng', 'ng', 'aria'];

    /**
     * @var array
     * @psalm-var array<string, int>
     */
    private static array $generateIdCounter = [];

    /**
     * Returns an autogenerated sequential ID.
     *
     * @param string $prefix
     *
     * @return string Autogenerated ID.
     */
    public static function generateId(string $prefix = 'i'): string
    {
        $prefix .= hrtime(true);
        if (isset(self::$generateIdCounter[$prefix])) {
            $counter = ++self::$generateIdCounter[$prefix];
        } else {
            $counter = 1;
            self::$generateIdCounter = [$prefix => $counter];
        }
        return $prefix . $counter;
    }

    /**
     * Encodes special characters into HTML entities for use as a tag content
     * i.e. `<div>tag content</div>`.
     * Characters encoded are: &, <, >.
     *
     * @param mixed $content The content to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded content.
     *
     * @see https://html.spec.whatwg.org/#data-state
     */
    public static function encode($content, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        return htmlspecialchars(
            (string)$content,
            ENT_NOQUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );
    }

    /**
     * Encodes special characters into HTML entities for use as HTML tag unquoted attribute value
     * i.e. `<input value=my-value>`.
     * Characters encoded are: &, <, >, ", ', `, =, tab, space, U+000A (form feed), U+0000 (null).
     *
     * @param mixed $value The attribute value to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded attribute value.
     *
     * @see https://html.spec.whatwg.org/#attribute-value-(unquoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
     */
    public static function encodeUnquotedAttribute($value, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        $value = htmlspecialchars(
            (string)$value,
            ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );

        return strtr($value, [
            "\t" => '&Tab;', // U+0009 CHARACTER TABULATION (tab)
            "\n" => '&NewLine;', // U+000A LINE FEED (LF)
            "\u{000c}" => '&#12;', // U+000C FORM FEED (FF)
            "\u{0000}" => '&#0;', // U+0000 NULL
            ' ' => '&#32;', // U+0020 SPACE
            '=' => '&equals;', // U+003D EQUALS SIGN (=)
            '`' => '&grave;', // U+0060 GRAVE ACCENT (`)
        ]);
    }

    /**
     * Encodes special characters into HTML entities for use as HTML tag quoted attribute value
     * i.e. `<input value="my-value">`.
     * Characters encoded are: &, <, >, ", ', U+0000 (null).
     *
     * @param mixed $value The attribute value to be encoded.
     * @param bool $doubleEncode If already encoded entities should be encoded.
     * @param string $encoding The encoding to use, defaults to "UTF-8".
     *
     * @return string Encoded attribute value.
     *
     * @see https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
     * @see https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
     */
    public static function encodeAttribute($value, $doubleEncode = true, string $encoding = 'UTF-8'): string
    {
        $value = htmlspecialchars(
            (string)$value,
            ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5,
            $encoding,
            $doubleEncode
        );

        return strtr($value, [
            "\u{0000}" => '&#0;', // U+0000 NULL
        ]);
    }

    /**
     * Escape special characters for use as JavaScript string value in a `<script` tag:
     *
     * ```
     * <script type="text/javascript">
     *     window.myVar = "<?= Html::escapeJavaScriptStringValue($myVar) ?>";
     * </script>
     * ```
     *
     * @param mixed $value JavaScript string.
     *
     * @return string Escaped JavaScript string.
     */
    public static function escapeJavaScriptStringValue($value): string
    {
        return strtr((string)$value, [
            '/' => '\/',
            '"' => '\"',
            "'" => "\'",
            '\\' => '\\\\',
        ]);
    }

    /**
     * Generates a complete HTML tag.
     *
     * @param bool|string|null $name The tag name. If $name is `null` or `false`, the corresponding content will be
     * rendered without any tag.
     * @param string $content The content to be enclosed between the start and end tags. It will not be HTML-encoded.
     * If this is coming from end users, you should consider {@see encode()} it to prevent XSS attacks.
     * @param array $options The HTML tag attributes (HTML options) in terms of name-value pairs. These will be
     * rendered as the attributes of the resulting tag. The values will be HTML-encoded using
     * {@see encodeAttribute()}. If a value is null, the corresponding attribute will not be rendered.
     *
     * For example when using `['class' => 'my-class', 'target' => '_blank', 'value' => null]` it will result in the
     * HTML attributes rendered like this: `class="my-class" target="_blank"`.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param HtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated HTML tag.
     *
     * @see beginTag()
     * @see endTag()
     */
    public static function tag($name, string $content = '', array $options = []): string
    {
        if ($name === null || is_bool($name)) {
            return $content;
        }

        $html = '<' . $name . self::renderTagAttributes($options) . '>';

        return isset(self::VOID_ELEMENTS[strtolower($name)]) ? $html : "$html$content</$name>";
    }

    /**
     * Generates a start tag.
     *
     * @param bool|string|null $name The tag name. If $name is `null` or `false`, the corresponding content will be
     * rendered without any tag.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * {@see endTag()}
     * {@see tag()}
     *
     * @return string The generated start tag.
     */
    public static function beginTag($name, array $options = []): string
    {
        if ($name === null || is_bool($name)) {
            return '';
        }

        return '<' . $name . self::renderTagAttributes($options) . '>';
    }

    /**
     * Generates an end tag.
     *
     * @param bool|string|null $name The tag name. If $name is `null` or `false`, the corresponding content will be
     * rendered without any tag.
     *
     * @return string The generated end tag.
     *
     * {@see beginTag()}
     * {@see tag()}
     */
    public static function endTag($name): string
    {
        if ($name === null || is_bool($name)) {
            return '';
        }

        return "</$name>";
    }

    /**
     * Generates a style tag.
     *
     * @param string $content The style content.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null, the
     * corresponding attribute will not be rendered. See {@see renderTagAttributes()} for details on how attributes
     * are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated style tag.
     */
    public static function style(string $content, array $options = []): string
    {
        return self::tag('style', $content, $options);
    }

    /**
     * Generates a script tag.
     *
     * @param string $content The script content.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered. See {@see renderTagAttributes()} for details on how attributes
     * are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated script tag.
     */
    public static function script(string $content, array $options = []): string
    {
        return self::tag('script', $content, $options);
    }

    /**
     * Generates a link tag that refers to an external CSS file.
     *
     * @param string $url The URL of the external CSS file. This parameter will be processed.
     * @param array $options The tag options in terms of name-value pairs. The following options are specially handled:
     *
     * - noscript: if set to true, `link` tag will be wrapped into `<noscript>` tags.
     *
     * The rest of the options will be rendered as the attributes of the resulting link tag. The values will be
     * HTML-encoded using {@see encodeAttribute()}. If a value is null, the corresponding attribute
     * will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param HtmlOptions&array{
     *   noscript?: bool,
     * } $options
     *
     * @throws JsonException
     *
     * @return string The generated link tag.
     */
    public static function cssFile(string $url, array $options = []): string
    {
        if (!isset($options['rel'])) {
            $options['rel'] = 'stylesheet';
        }
        $options['href'] = $url;

        if (isset($options['noscript']) && $options['noscript'] === true) {
            unset($options['noscript']);
            return '<noscript>' . self::tag('link', '', $options) . '</noscript>';
        }

        return self::tag('link', '', $options);
    }

    /**
     * Generates a script tag that refers to an external JavaScript file.
     *
     * @param string $url The URL of the external JavaScript file. This parameter will be processed.
     * @param array $options The tag options in terms of name-value pairs.
     * Options will be rendered as the attributes of the resulting script tag. The values will be
     * HTML-encoded using {@see encodeAttribute()}. If a value is null, the corresponding attribute will
     * not be rendered. See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param HtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated script tag.
     */
    public static function javaScriptFile(string $url, array $options = []): string
    {
        $options['src'] = $url;
        return self::tag('script', '', $options);
    }

    /**
     * Generates a hyperlink tag.
     *
     * @param string $text Link body. It will NOT be HTML-encoded. Therefore you can pass in HTML code such as an image
     * tag. If this is coming from end users, you should consider {@see encode()} it to prevent XSS attacks.
     * @param array|string|null $url The URL for the hyperlink tag. This parameter will be processed and will be used
     * for the "href" attribute of the tag. If this parameter is null, the "href" attribute will not
     * be generated.
     *
     * If you want to use an absolute url you can call yourself, before passing the URL to this method, like this:
     *
     * ```php
     * Html::a('link text', $url, true))
     * ```
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}.
     * If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated hyperlink.
     */
    public static function a(string $text, $url = null, array $options = []): string
    {
        if ($url !== null) {
            $options['href'] = $url;
        }

        return self::tag('a', $text, $options);
    }

    /**
     * Generates a mailto hyperlink.
     *
     * @param string $text Link body. It will NOT be HTML-encoded. Therefore you can pass in HTML code such as an image
     * tag. If this is coming from end users, you should consider {@see encode()} it to prevent XSS attacks.
     * @param string|null $email Email address. If this is null, the first parameter (link body) will be treated
     * as the email address and used.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated mailto link.
     */
    public static function mailto(string $text, ?string $email = null, array $options = []): string
    {
        $options['href'] = 'mailto:' . ($email ?? $text);
        return self::tag('a', $text, $options);
    }

    /**
     * Generates an image tag.
     *
     * @param string $src The image URL. This parameter will be processed.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}.
     * If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * It is possible to pass the `srcset` option as an array which keys are descriptors and
     * values are URLs. All URLs will be processed.
     *
     * @psalm-param HtmlOptions&array{
     *   srcset?: string[]|string|null,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated image tag.
     */
    public static function img(string $src, array $options = []): string
    {
        $options['src'] = $src;

        if (isset($options['srcset']) && is_array($options['srcset'])) {
            $srcset = [];
            foreach ($options['srcset'] as $descriptor => $url) {
                $srcset[] = $url . ' ' . $descriptor;
            }
            $options['srcset'] = implode(',', $srcset);
        }

        if (!isset($options['alt'])) {
            $options['alt'] = '';
        }

        return self::tag('img', '', $options);
    }

    /**
     * Generates a label tag.
     *
     * @param string $content Label text. It will NOT be HTML-encoded. Therefore you can pass in HTML code such as an
     * image tag. If this is is coming from end users, you should {@see encode()} it to prevent XSS attacks.
     * @param string|null $for The ID of the HTML element that this label is associated with.
     * If this is null, the "for" attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null, the
     * corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated label tag.
     */
    public static function label(string $content, ?string $for = null, array $options = []): string
    {
        $options['for'] = $for;
        return self::tag('label', $content, $options);
    }

    /**
     * Generates a button tag.
     *
     * @param string $content The content enclosed within the button tag. It will NOT be HTML-encoded. Therefore you
     * can pass in HTML code such as an image tag. If this is is coming from end users, you should consider
     * {@see encode()} it to prevent XSS attacks.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null, the
     * corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated button tag.
     */
    public static function button(string $content = 'Button', array $options = []): string
    {
        if (!isset($options['type'])) {
            $options['type'] = 'button';
        }

        return self::tag('button', $content, $options);
    }

    /**
     * Generates a submit button tag.
     *
     * Be careful when naming form elements such as submit buttons. According to the [jQuery documentation]
     * (https://api.jquery.com/submit/) there are some reserved names that can cause conflicts, e.g. `submit`, `length`
     * or `method`.
     *
     * @param string $content The content enclosed within the button tag. It will NOT be HTML-encoded. Therefore you
     * can pass in HTML code such as an image tag. If this is is coming from end users, you should consider
     * {@see encode()} it to prevent XSS attacks.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated submit button tag.
     */
    public static function submitButton(string $content = 'Submit', array $options = []): string
    {
        $options['type'] = 'submit';

        return self::button($content, $options);
    }

    /**
     * Generates a reset button tag.
     *
     * @param string $content The content enclosed within the button tag. It will NOT be HTML-encoded. Therefore you
     * can pass in HTML code such as an image tag. If this is is coming from end users, you should consider
     * {@see encode()} it to prevent XSS attacks.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated reset button tag.
     */
    public static function resetButton(string $content = 'Reset', array $options = []): string
    {
        $options['type'] = 'reset';

        return self::button($content, $options);
    }

    /**
     * Generates an input type of the given type.
     *
     * @param string $type The type attribute.
     * @param string|null $name The name attribute. If it is null, the name attribute will not be generated.
     * @param bool|float|int|string|null $value the value attribute. If it is null, the value attribute will
     * not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}.
     * If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param string|int|float|\Stringable|bool|null $value
     * @psalm-param InputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated input tag.
     */
    public static function input(string $type, ?string $name = null, $value = null, array $options = []): string
    {
        if (!isset($options['type'])) {
            $options['type'] = $type;
        }

        $options['name'] = $name;
        $options['value'] = $value;

        return self::tag('input', '', $options);
    }

    /**
     * Generates an input button.
     *
     * @param string $label The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated button tag.
     */
    public static function buttonInput(string $label = 'Button', array $options = []): string
    {
        $options['type'] = 'button';
        $options['value'] = $label;

        return self::tag('input', '', $options);
    }

    /**
     * Generates a submit input button.
     *
     * Be careful when naming form elements such as submit buttons. According to the {@see jQuery documentation}
     * https://api.jquery.com/submit/) there are some reserved names that can cause conflicts, e.g. `submit`, `length`
     * or `method`.
     *
     * @param string $label The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated button tag.
     */
    public static function submitInput($label = 'Submit', $options = []): string
    {
        $options['type'] = 'submit';
        $options['value'] = $label;

        return self::tag('input', '', $options);
    }

    /**
     * Generates a reset input button.
     *
     * @param string $label The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The attributes of the button tag. The values will be HTML-encoded using
     * {@see encodeAttribute()}. Attributes whose value is null will be ignored and not put in the tag returned.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @throws JsonException
     *
     * @return string The generated button tag.
     */
    public static function resetInput(string $label = 'Reset', array $options = []): string
    {
        $options['type'] = 'reset';
        $options['value'] = $label;

        return self::tag('input', '', $options);
    }

    /**
     * Generates a text input field.
     *
     * @param string $name The name attribute.
     * @param string|null $value The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as
     * the attributes of the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}.
     * If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param InputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated text input tag.
     */
    public static function textInput(string $name, ?string $value = null, array $options = []): string
    {
        return self::input('text', $name, $value, $options);
    }

    /**
     * Generates a hidden input field.
     *
     * @param string $name The name attribute.
     * @param bool|float|int|string|null $value The value attribute.
     * If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param string|int|float|\Stringable|bool|null $value
     * @psalm-param InputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated hidden input tag.
     */
    public static function hiddenInput(string $name, $value = null, array $options = []): string
    {
        return self::input('hidden', $name, $value, $options);
    }

    /**
     * Generates a password input field.
     *
     * @param string $name The name attribute.
     * @param string|null $value The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param InputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated password input tag.
     */
    public static function passwordInput(string $name, ?string $value = null, array $options = []): string
    {
        return self::input('password', $name, $value, $options);
    }

    /**
     * Generates a file input field.
     *
     * To use a file input field, you should set the enclosing form's "enctype" attribute to be "multipart/form-data".
     * After the form is submitted, the uploaded file information can be obtained via $_FILES[$name]
     * (see PHP documentation).
     *
     * @param string $name The name attribute.
     * @param string|null $value The value attribute. If it is null, the value attribute will not be generated.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as
     * the attributes of the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}.
     * If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param InputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated file input tag.
     */
    public static function fileInput(string $name, ?string $value = null, array $options = []): string
    {
        return self::input('file', $name, $value, $options);
    }

    /**
     * Generates a text area input.
     *
     * @param string $name The input name.
     * @param string|null $value The input value. Note that it will be encoded using {@see encode()}.
     * @param array $options The tag options in terms of name-value pairs. These will be rendered as the attributes of
     * the resulting tag. The values will be HTML-encoded using {@see encodeAttribute()}. If a value is null,
     * the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     * The following special options are recognized:
     *
     * - `doubleEncode`: whether to double encode HTML entities in `$value`. If `false`, HTML entities in `$value` will
     *   not be further encoded.
     *
     * @psalm-param HtmlOptions&array{
     *   doubleEncode?: bool,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated text area tag.
     */
    public static function textarea(string $name, ?string $value = '', array $options = []): string
    {
        $options['name'] = $name;

        /** @var bool $doubleEncode */
        $doubleEncode = ArrayHelper::remove($options, 'doubleEncode', true);

        return self::tag('textarea', self::encode($value, $doubleEncode), $options);
    }

    /**
     * Generates a radio button input.
     *
     * @param string $name The name attribute.
     * @param bool $checked Whether the radio button should be checked.
     * @param array $options The tag options in terms of name-value pairs.
     * See {@see booleanInput()} for details about accepted attributes.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated radio button tag.
     */
    public static function radio(string $name, bool $checked = false, array $options = []): string
    {
        return self::booleanInput('radio', $name, $checked, $options);
    }

    /**
     * Generates a checkbox input.
     *
     * @param string $name The name attribute.
     * @param bool $checked Whether the checkbox should be checked.
     * @param array $options The tag options in terms of name-value pairs.
     * See {@see booleanInput()} for details about accepted attributes.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox tag.
     */
    public static function checkbox(string $name, bool $checked = false, array $options = []): string
    {
        return self::booleanInput('checkbox', $name, $checked, $options);
    }

    /**
     * Generates a boolean input.
     *
     * @param string $type The input type. This can be either `radio` or `checkbox`.
     * @param string $name The name attribute.
     * @param bool $checked Whether the checkbox should be checked.
     * @param array $options The tag options in terms of name-value pairs. The following options are specially handled:
     *
     * - uncheck: string, the value associated with the uncheck state of the checkbox. When this attribute is present,
     *   a hidden input will be generated so that if the checkbox is not checked and is submitted, the value of this
     *   attribute will still be submitted to the server via the hidden input.
     * - label: string, a label displayed next to the checkbox. It will NOT be HTML-encoded. Therefore you can pass in
     *   HTML code such as an image tag. If this is is coming from end users, you should {@see encode()}
     *   it to prevent XSS attacks.
     *   When this option is specified, the checkbox will be enclosed by a label tag.
     * - labelOptions: array, the HTML attributes for the label tag. Do not set this option unless you set the "label"
     *   option.
     * - wrapInput: bool, use when has label.
     *   if `wrapInput` is true result will be `<label><input> Label</label>`,
     *   else `<input> <label>Label</label>`
     *
     * The rest of the options will be rendered as the attributes of the resulting checkbox tag. The values will be
     * HTML-encoded using {@see encodeAttribute()}. If a value is null, the corresponding attribute will not be
     * rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param BooleanInputHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox tag.
     */
    private static function booleanInput(string $type, string $name, bool $checked, array $options): string
    {
        $options['checked'] = $checked;
        $value = array_key_exists('value', $options) ? $options['value'] : '1';

        if (isset($options['uncheck'])) {
            // Add a hidden field so that if the checkbox is not selected, it still submits a value.
            $hiddenOptions = [];
            if (isset($options['form'])) {
                $hiddenOptions['form'] = $options['form'];
            }
            // Make sure disabled input is not sending any value.
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput($name, $options['uncheck'], $hiddenOptions);

            unset($options['uncheck']);
        } else {
            $hidden = '';
        }

        $label = $options['label'] ?? null;
        $labelOptions = $options['labelOptions'] ?? [];
        $wrapInput = $options['wrapInput'] ?? true;
        unset($options['label'], $options['labelOptions'], $options['wrapInput']);

        if (empty($label)) {
            return $hidden . self::input($type, $name, $value, $options);
        }

        if ($wrapInput) {
            $input = self::input($type, $name, $value, $options);
            return $hidden . self::label($input . ' ' . $label, null, $labelOptions);
        }

        if (!isset($options['id'])) {
            $options['id'] = self::generateId();
        }
        return $hidden .
            self::input($type, $name, $value, $options) .
            ' ' .
            self::label($label, $options['id'], $labelOptions);
    }

    /**
     * Generates a drop-down list.
     *
     * @param string $name The input name.
     * @param iterable|string|null $selection The selected value(s). String for single or array for multiple
     * selection(s).
     * @param array $items The option data items. The array keys are option values, and the array values are the
     * corresponding option labels. The array can also be nested (i.e. some array values are arrays too). For each
     * sub-array, an option group will be generated whose label is the key associated with the sub-array. If you have a
     * list of data models, you may convert them into the format described above using
     * {@see \Yiisoft\Arrays\ArrayHelper::map()}.
     *
     * Note, the values and labels will be automatically HTML-encoded by this method, and the blank spaces in the
     * labels will also be HTML-encoded.
     * @param array $options The tag options in terms of name-value pairs. The following options are specially handled:
     *
     * - prompt: string, a prompt text to be displayed as the first option. You can use an array to override the value
     *   and to set other tag attributes:
     *
     *   ```php
     *   ['text' => 'Please select', 'options' => ['value' => 'none', 'class' => 'prompt', 'label' => 'Select']],
     *   ```
     *
     * - options: array, the attributes for the select option tags. The array keys must be valid option values, and the
     *   array values are the extra attributes for the corresponding option tags. For example,
     *
     *   ```php
     *   [
     *       'value1' => ['disabled' => true],
     *       'value2' => ['label' => 'value 2'],
     *   ];
     *   ```
     *
     * - groups: array, the attributes for the optgroup tags. The structure of this is similar to that of 'options',
     *   except that the array keys represent the optgroup labels specified in $items.
     * - encodeSpaces: bool, whether to encode spaces in option prompt and option value with `&nbsp;` character.
     *   Defaults to false.
     * - encode: bool, whether to encode option prompt and option value characters. Defaults to `true`.
     *
     * The rest of the options will be rendered as the attributes of the resulting tag. The values will be HTML-encoded
     * using {@see encodeAttribute()}. If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|null $selection
     * @psalm-param SelectItems $items
     * @psalm-param ListBoxHtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated drop-down list tag.
     */
    public static function dropDownList(string $name, $selection = null, array $items = [], array $options = []): string
    {
        if (!empty($options['multiple'])) {
            return self::listBox($name, $selection, $items, $options);
        }

        $options['name'] = $name;

        unset($options['unselect']);

        $selectOptions = self::renderSelectOptionTags($selection, $items, $options);

        return self::tag('select', "\n" . $selectOptions . "\n", $options);
    }

    /**
     * Generates a list box.
     *
     * @param string $name The input name.
     * @param iterable|string|null $selection The selected value(s). String for single or array for multiple
     * selection(s).
     * @param array $items The option data items. The array keys are option values, and the array values are the
     * corresponding option labels. The array can also be nested (i.e. some array values are arrays too). For each
     * sub-array, an option group will be generated whose label is the key associated with the sub-array. If you have a
     * list of data models, you may convert them into the format described above using
     * {@see \Yiisoft\Arrays\ArrayHelper::map()}.
     *
     * Note, the values and labels will be automatically HTML-encoded by this method, and the blank spaces in the
     * labels will also be HTML-encoded.
     * @param array $options The tag options in terms of name-value pairs. The following options are specially handled:
     *
     * - prompt: string, a prompt text to be displayed as the first option. You can use an array to override the value
     *   and to set other tag attributes:
     *
     *   ```php
     *   ['text' => 'Please select', 'options' => ['value' => 'none', 'class' => 'prompt', 'label' => 'Select']],
     *   ```
     *
     * - options: array, the attributes for the select option tags. The array keys must be valid option values, and the
     *   array values are the extra attributes for the corresponding option tags. For example,
     *
     *   ```php
     *   [
     *       'value1' => ['disabled' => true],
     *       'value2' => ['label' => 'value 2'],
     *   ];
     *   ```
     *
     * - groups: array, the attributes for the optgroup tags. The structure of this is similar to that of 'options',
     *   except that the array keys represent the optgroup labels specified in $items.
     * - unselect: string, the value that will be submitted when no option is selected.
     *   When this attribute is set, a hidden field will be generated so that if no option is selected in multiple
     *   mode, we can still obtain the posted unselect value.
     * - encodeSpaces: bool, whether to encode spaces in option prompt and option value with `&nbsp;` character.
     *   Defaults to false.
     * - encode: bool, whether to encode option prompt and option value characters. Defaults to `true`.
     *
     * The rest of the options will be rendered as the attributes of the resulting tag. The values will be HTML-encoded
     * using {@see encodeAttribute()}. If a value is null, the corresponding attribute will not be rendered.
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|null $selection
     * @psalm-param SelectItems $items
     * @psalm-param ListBoxHtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated list box tag.
     */
    public static function listBox(string $name, $selection = null, array $items = [], array $options = []): string
    {
        if (!array_key_exists('size', $options)) {
            $options['size'] = 4;
        }

        if (!empty($options['multiple']) && !empty($name)) {
            $name = self::getArrayableName($name);
        }

        $options['name'] = $name;

        if (isset($options['unselect'])) {
            // Add a hidden field so that if the list box has no option being selected, it still submits a value.
            $name = self::getNonArrayableName($name);
            $hiddenOptions = [];
            // Make sure disabled input is not sending any value.
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput($name, $options['unselect'], $hiddenOptions);
            unset($options['unselect']);
        } else {
            $hidden = '';
        }

        /** @var SelectHtmlOptions $options */
        $selectOptions = self::renderSelectOptionTags($selection, $items, $options);

        return $hidden . self::tag('select', "\n" . $selectOptions . "\n", $options);
    }

    /**
     * Generates a list of checkboxes.
     *
     * A checkbox list allows multiple selection, like {@see listBox()}. As a result, the corresponding submitted value
     * is an array.
     *
     * @param string $name The name attribute of each checkbox.
     * @param array|bool|float|int|string|Traversable|null $selection The selected value(s). String for single or array
     * for multiple selection(s).
     * @param array $items The data item used to generate the checkboxes. The array keys are the checkbox values, while
     * the array values are the corresponding labels.
     * @param array $options Options (name => config) for the checkbox list container tag. The following options are
     * specially handled:
     *
     * - tag: string|false, the tag name of the container element. False to render checkbox without container.
     *   See also {@see tag()}.
     * - unselect: string, the value that should be submitted when none of the checkboxes is selected. By setting this
     *   option, a hidden input will be generated.
     * - encode: boolean, whether to HTML-encode the checkbox labels. Defaults to true. This option is ignored if `item`
     *   option is set.
     * - separator: string, the HTML code that separates items.
     * - itemOptions: array, the options for generating the checkbox tag using {@see checkbox()}.
     * - item: callable, a callback that can be used to customize the generation of the HTML code corresponding to a
     *   single item in $items. The signature of this callback must be:
     *
     *   ```php
     *   function ($index, $label, $name, $checked, $value)
     *   ```
     *
     *   where $index is the zero-based index of the checkbox in the whole list; $label is the label for the checkbox;
     *   and $name, $value and $checked represent the name, value and the checked status of the checkbox input,
     *   respectively.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|\Stringable|int|float|bool|null $selection
     * @psalm-param array<array-key, string> $items
     * @psalm-param InputHtmlOptions&array{
     *   item?: Closure(int, string, string, bool, mixed):string|null,
     *   itemOptions?: HtmlOptions|null,
     *   encode?: bool,
     *   separator?: string|null,
     *   tag?: string|null,
     *   unselect?: string|int|float|\Stringable|bool|null,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated checkbox list.
     */
    public static function checkboxList(string $name, $selection = null, array $items = [], array $options = []): string
    {
        $name = self::getArrayableName($name);

        if (is_iterable($selection)) {
            $selection = array_map('\strval', is_array($selection) ? $selection : iterator_to_array($selection));
        } elseif ($selection !== null) {
            $selection = (string)$selection;
        }

        /** @var Closure(int, string, string, bool, mixed):string|null $formatter */
        $formatter = ArrayHelper::remove($options, 'item');

        /** @psalm-var HtmlOptions $itemOptions */
        $itemOptions = ArrayHelper::remove($options, 'itemOptions', []);

        /** @var bool $encode */
        $encode = ArrayHelper::remove($options, 'encode', true);

        /** @var string $separator */
        $separator = ArrayHelper::remove($options, 'separator', "\n");

        /** @var string $tag */
        $tag = ArrayHelper::remove($options, 'tag', 'div');

        /** @psalm-var InputHtmlOptions&array{unselect?: string|int|float|\Stringable|bool|null} $options */

        $lines = [];
        $index = 0;
        foreach ($items as $value => $label) {
            $checked = $selection !== null &&
                ((!is_iterable($selection) && !strcmp((string)$value, $selection))
                    || (is_iterable($selection) && ArrayHelper::isIn((string)$value, $selection)));
            if ($formatter !== null) {
                $lines[] = $formatter($index, $label, $name, $checked, $value);
            } else {
                $lines[] = self::checkbox($name, $checked, array_merge([
                    'value' => $value,
                    'label' => $encode ? self::encode($label) : $label,
                ], $itemOptions));
            }
            $index++;
        }

        if (isset($options['unselect'])) {
            // Add a hidden field so that if the list box has no option being selected, it still submits a value.
            $name2 = self::getNonArrayableName($name);
            $hiddenOptions = [];
            // Make sure disabled input is not sending any value.
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput($name2, $options['unselect'], $hiddenOptions);
            unset($options['unselect'], $options['disabled']);
        } else {
            $hidden = '';
        }

        return $hidden . self::tag($tag, implode($separator, $lines), $options);
    }

    /**
     * Generates a list of radio buttons.
     *
     * A radio button list is like a checkbox list, except that it only allows single selection.
     *
     * @param string $name The name attribute of each radio button.
     * @param array|bool|float|int|string|Traversable|null $selection The selected value(s). String for single or array
     * for multiple selection(s).
     * @param array $items The data item used to generate the radio buttons. The array keys are the radio button
     * values, while the array values are the corresponding labels.
     * @param array $options Options (name => config) for the radio button list container tag. The following options
     * are specially handled:
     *
     * - tag: string|false, the tag name of the container element. False to render radio buttons without container.
     *   See also {@see tag()}.
     * - unselect: string, the value that should be submitted when none of the radio buttons is selected. By setting
     *   this option, a hidden input will be generated.
     * - encode: boolean, whether to HTML-encode the checkbox labels. Defaults to true. This option is ignored if `item`
     *   option is set.
     * - separator: string, the HTML code that separates items.
     * - itemOptions: array, the options for generating the radio button tag using {@see radio()}.
     * - item: callable, a callback that can be used to customize the generation of the HTML code corresponding to a
     *   single item in $items. The signature of this callback must be:
     *
     *   ```php
     *   function ($index, $label, $name, $checked, $value)
     *   ```
     *
     *   where $index is the zero-based index of the radio button in the whole list; $label is the label for the radio
     *   button; and $name, $value and $checked represent the name, value and the checked status of the radio button
     *   input, respectively.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param iterable<array-key, string>|string|\Stringable|int|float|bool|null $selection
     * @psalm-param array<array-key, string> $items
     * @psalm-param InputHtmlOptions&array{
     *   item?: Closure(int, string, string, bool, mixed):string|null,
     *   itemOptions?: HtmlOptions|null,
     *   encode?: bool,
     *   separator?: string|null,
     *   tag?: string|null,
     *   unselect?: string|int|float|\Stringable|bool|null,
     * }|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated radio button list.
     */
    public static function radioList(string $name, $selection = null, array $items = [], array $options = []): string
    {
        if (is_iterable($selection)) {
            $selection = array_map('strval', is_array($selection) ? $selection : iterator_to_array($selection));
        } elseif ($selection !== null) {
            $selection = (string)$selection;
        }

        /** @var Closure(int, string, string, bool, mixed):string|null $formatter */
        $formatter = ArrayHelper::remove($options, 'item');

        /** @psalm-var HtmlOptions $itemOptions */
        $itemOptions = ArrayHelper::remove($options, 'itemOptions', []);

        /** @var bool $encode */
        $encode = ArrayHelper::remove($options, 'encode', true);

        /** @var string $separator */
        $separator = ArrayHelper::remove($options, 'separator', "\n");

        /** @var string $tag */
        $tag = ArrayHelper::remove($options, 'tag', 'div');

        /** @psalm-var InputHtmlOptions&array{unselect?: string|int|float|\Stringable|bool|null} $options */

        $hidden = '';
        if (isset($options['unselect'])) {
            // add a hidden field so that if the list box has no option being selected, it still submits a value
            $hiddenOptions = [];
            // make sure disabled input is not sending any value
            if (!empty($options['disabled'])) {
                $hiddenOptions['disabled'] = $options['disabled'];
            }
            $hidden = self::hiddenInput($name, $options['unselect'], $hiddenOptions);
            unset($options['unselect'], $options['disabled']);
        }

        $lines = [];
        $index = 0;
        foreach ($items as $value => $label) {
            $checked = $selection !== null &&
                ((!is_iterable($selection) && !strcmp((string)$value, $selection))
                    || (is_iterable($selection) && ArrayHelper::isIn((string)$value, $selection)));
            if ($formatter !== null) {
                $lines[] = $formatter($index, $label, $name, $checked, $value);
            } else {
                $lines[] = self::radio($name, $checked, array_merge([
                    'value' => $value,
                    'label' => $encode ? self::encode($label) : $label,
                ], $itemOptions));
            }
            $index++;
        }
        $visibleContent = implode($separator, $lines);

        return $hidden . self::tag($tag, $visibleContent, $options);
    }

    /**
     * Generates a div tag. Based on {@see Html::tag()}.
     *
     * @param string $content Tag content.
     * @param array $options Tag options.
     *
     * @psalm-param HtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated div.
     */
    public static function div(string $content = '', array $options = []): string
    {
        return self::tag('div', $content, $options);
    }

    /**
     * Generates a span tag. Based on {@see Html::tag()}.
     *
     * @param string $content Tag content.
     * @param array $options Tag options.
     *
     * @psalm-param HtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated span.
     */
    public static function span(string $content = '', array $options = []): string
    {
        return self::tag('span', $content, $options);
    }

    /**
     * Generates a paragraph tag. Based on {@see Html::tag()}.
     *
     * @param string $content Tag content.
     * @param array $options Tag options.
     *
     * @psalm-param HtmlOptions|array<empty, empty> $options
     *
     * @throws JsonException
     *
     * @return string The generated paragraph.
     */
    public static function p(string $content = '', array $options = []): string
    {
        return self::tag('p', $content, $options);
    }

    /**
     * Generates an unordered list.
     *
     * @param array|Traversable $items The items for generating the list. Each item generates a single list item. Note
     * that items will be automatically HTML encoded if `$options['encode']` is not set or true.
     * @param array $options Options (name => config) for the radio button list. The following options are supported:
     *
     * - encode: boolean, whether to HTML-encode the items. Defaults to true. This option is ignored if the `item`
     *   option is specified.
     * - separator: string, the HTML code that separates items. Defaults to a simple newline (`"\n"`). This option is
     *   available.
     * - itemOptions: array, the HTML attributes for the `li` tags. This option is ignored if the `item` option is
     *   specified.
     * - item: callable, a callback that is used to generate each individual list item. The signature of this callback
     *   must be:
     *
     *   ```php
     *   function ($item, $index)
     *   ```
     *
     *   where $index is the array key corresponding to `$item` in `$items`. The callback should return the whole list
     *   item tag.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param array<array-key, string> $items
     * @psalm-param ListHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated unordered list. An empty list tag will be returned if `$items` is empty.
     */
    public static function ul($items, array $options = []): string
    {
        /** @var string $tag */
        $tag = ArrayHelper::remove($options, 'tag', 'ul');

        /** @var bool $encode */
        $encode = ArrayHelper::remove($options, 'encode', true);

        /** @var Closure(string, array-key):string|null $formatter */
        $formatter = ArrayHelper::remove($options, 'item');

        /** @var string $separator */
        $separator = ArrayHelper::remove($options, 'separator', "\n");

        /** @psalm-var HtmlOptions $itemOptions */
        $itemOptions = ArrayHelper::remove($options, 'itemOptions', []);


        if (empty($items)) {
            return self::tag($tag, '', $options);
        }

        $results = [];
        foreach ($items as $index => $item) {
            if ($formatter !== null) {
                $results[] = $formatter($item, $index);
            } else {
                $results[] = self::tag('li', $encode ? self::encode($item) : $item, $itemOptions);
            }
        }

        return self::tag(
            $tag,
            $separator . implode($separator, $results) . $separator,
            $options
        );
    }

    /**
     * Generates an ordered list.
     *
     * @param array|Traversable $items The items for generating the list. Each item generates a single list item. Note
     * that items will be automatically HTML encoded if `$options['encode']` is not set or true.
     * @param array $options Options (name => config) for the radio button list. The following options are supported:
     *
     * - encode: boolean, whether to HTML-encode the items. Defaults to true. This option is ignored if the `item`
     *   option is specified.
     * - itemOptions: array, the HTML attributes for the `li` tags. This option is ignored if the `item` option is
     *   specified.
     * - item: callable, a callback that is used to generate each individual list item. The signature of this callback
     *   must be:
     *
     *   ```php
     *   function ($item, $index)
     *   ```
     *
     *   where $index is the array key corresponding to `$item` in `$items`. The callback should return the whole list
     *   item tag.
     *
     * See {@see renderTagAttributes()} for details on how attributes are being rendered.
     *
     * @psalm-param array<array-key, string> $items
     * @psalm-param ListHtmlOptions $options
     *
     * @throws JsonException
     *
     * @return string The generated ordered list. An empty string is returned if `$items` is empty.
     */
    public static function ol($items, array $options = []): string
    {
        $options['tag'] = 'ol';

        return self::ul($items, $options);
    }

    /**
     * Renders the option tags that can be used by {@see dropDownList()} and {@see listBox()}.
     *
     * @param array|bool|float|int|string|Traversable|null $selection The selected value(s). String for single or array
     * for multiple selection(s).
     * @param array $items The option data items. The array keys are option values, and the array values are the
     * corresponding option labels. The array can also be nested (i.e. some array values are arrays too). For each
     * sub-array, an option group will be generated whose label is the key associated with the sub-array. If you have a
     * list of data models, you may convert them into the format described above using
     * {@see \Yiisoft\Arrays\ArrayHelper::map()}.
     *
     * Note, the values and labels will be automatically HTML-encoded by this method, and the blank spaces in the
     * labels will also be HTML-encoded.
     * @param array $tagOptions The $options parameter that is passed to the {@see dropDownList()} or {@see listBox()}
     * call. This method will take out these elements, if any: "prompt", "options" and "groups". See more details in
     * {@see dropDownList()} for the explanation of these elements.
     *
     * @psalm-param iterable<array-key, string>|string|null $selection
     * @psalm-param SelectItems $items
     * @psalm-param SelectHtmlOptions $tagOptions
     *
     * @throws JsonException
     *
     * @return string The generated list options.
     */
    public static function renderSelectOptions($selection, array $items, array $tagOptions = []): string
    {
        return self::renderSelectOptionTags($selection, $items, $tagOptions);
    }

    /**
     * @param array|bool|float|int|string|Traversable|null $selection
     * @param array $items
     * @param array $tagOptions
     *
     * @psalm-param iterable<array-key, string>|string|\Stringable|int|float|bool|null $selection
     * @psalm-param SelectItems $items
     * @psalm-param SelectHtmlOptions $tagOptions
     *
     * @throws JsonException
     *
     * @return string
     */
    private static function renderSelectOptionTags($selection, array $items, array &$tagOptions): string
    {
        if (is_iterable($selection)) {
            $selection = array_map('strval', is_array($selection) ? $selection : iterator_to_array($selection));
        } elseif ($selection !== null) {
            $selection = (string)$selection;
        }

        /** @var bool $encodeSpaces */
        $encodeSpaces = ArrayHelper::remove($tagOptions, 'encodeSpaces', false);

        /** @var bool $encode */
        $encode = ArrayHelper::remove($tagOptions, 'encode', true);

        /** @psalm-var SelectHtmlOptions $tagOptions */

        $lines = [];
        if (isset($tagOptions['prompt'])) {
            $promptOptions = ['value' => ''];
            if (is_string($tagOptions['prompt'])) {
                $promptText = $tagOptions['prompt'];
            } else {
                $promptText = $tagOptions['prompt']['text'];
                $promptOptions = array_merge($promptOptions, $tagOptions['prompt']['options']);
            }
            $promptText = $encode ? self::encode($promptText) : $promptText;
            if ($encodeSpaces) {
                $promptText = str_replace(' ', '&nbsp;', $promptText);
            }
            $lines[] = self::tag('option', $promptText, $promptOptions);
        }

        /** @psalm-var array<array-key, HtmlOptions> $options */
        $options = $tagOptions['options'] ?? [];

        /** @psalm-var array<array-key, HtmlOptions> $groups */
        $groups = $tagOptions['groups'] ?? [];

        unset($tagOptions['prompt'], $tagOptions['options'], $tagOptions['groups']);

        foreach ($items as $key => $value) {
            if (is_array($value)) {
                $groupAttrs = $groups[$key] ?? [];
                if (!isset($groupAttrs['label'])) {
                    $groupAttrs['label'] = $key;
                }
                $attrs = [
                    'options' => $options,
                    'groups' => $groups,
                    'encodeSpaces' => $encodeSpaces,
                    'encode' => $encode,
                ];
                $content = self::renderSelectOptionTags($selection, $value, $attrs);
                $lines[] = self::tag('optgroup', "\n" . $content . "\n", $groupAttrs);
            } else {
                $attrs = $options[$key] ?? [];
                $attrs['value'] = $key;
                if (!array_key_exists('selected', $attrs)) {
                    $attrs['selected'] = $selection !== null &&
                        ((!is_iterable($selection) && !strcmp((string)$key, $selection))
                            || (is_iterable($selection) && ArrayHelper::isIn((string)$key, $selection)));
                }
                $text = $encode ? self::encode($value) : $value;
                if ($encodeSpaces) {
                    $text = str_replace(' ', '&nbsp;', $text);
                }
                $lines[] = self::tag('option', $text, $attrs);
            }
        }

        /** @psalm-var SelectHtmlOptions $tagOptions */
        return implode("\n", $lines);
    }

    /**
     * Renders the HTML tag attributes.
     *
     * Attributes whose values are of boolean type will be treated as
     * [boolean attributes](http://www.w3.org/TR/html5/infrastructure.html#boolean-attributes).
     *
     * Attributes whose values are null will not be rendered. The values of attributes will be HTML-encoded using
     * {@see encodeAttribute()}.
     *
     * The "data" attribute is specially handled when it is receiving an array value. In this case, the array will be
     * "expanded" and a list data attributes will be rendered. For example, if `'data' => ['id' => 1, 'name' => 'yii']`
     * then this will be rendered `data-id="1" data-name="yii"`.
     *
     * Additionally `'data' => ['params' => ['id' => 1, 'name' => 'yii'], 'status' => 'ok']` will be rendered as:
     * `data-params='{"id":1,"name":"yii"}' data-status="ok"`.
     *
     * @param array $attributes Attributes to be rendered. The attribute values will be HTML-encoded using
     * {@see encodeAttribute()}.
     *
     * @psalm-param HtmlOptions|array<empty, empty> $attributes
     *
     * @throws JsonException
     *
     * @return string The rendering result. If the attributes are not empty, they will be rendered into a string
     * with a leading white space (so that it can be directly appended to the tag name in a tag). If there is no
     * attribute, an empty string will be returned.
     */
    public static function renderTagAttributes(array $attributes): string
    {
        if (count($attributes) > 1) {
            $sorted = [];
            foreach (self::ATTRIBUTE_ORDER as $name) {
                if (isset($attributes[$name])) {
                    /** @psalm-suppress MixedAssignment */
                    $sorted[$name] = $attributes[$name];
                }
            }
            $attributes = array_merge($sorted, $attributes);
        }

        $html = '';
        /** @var mixed $value */
        foreach ($attributes as $name => $value) {
            if (is_bool($value)) {
                if ($value) {
                    $html .= " $name";
                }
            } elseif (is_array($value)) {
                if (in_array($name, self::DATA_ATTRIBUTES, true)) {
                    /** @psalm-var array<array-key, array|string|\Stringable|null> $value */
                    foreach ($value as $n => $v) {
                        if (is_array($v)) {
                            $html .= " $name-$n='" . Json::htmlEncode($v) . "'";
                        } else {
                            $html .= " $name-$n=\"" . self::encodeAttribute($v) . '"';
                        }
                    }
                } elseif ($name === 'class') {
                    if (empty($value)) {
                        continue;
                    }
                    $html .= " $name=\"" . self::encodeAttribute(implode(' ', $value)) . '"';
                } elseif ($name === 'style') {
                    if (empty($value)) {
                        continue;
                    }
                    /** @psalm-var array<string, string> $value */
                    $html .= " $name=\"" . self::encodeAttribute(self::cssStyleFromArray($value)) . '"';
                } else {
                    $html .= " $name='" . Json::htmlEncode($value) . "'";
                }
            } elseif ($value !== null) {
                $html .= " $name=\"" . self::encodeAttribute($value) . '"';
            }
        }

        return $html;
    }

    /**
     * Adds a CSS class (or several classes) to the specified options.
     *
     * If the CSS class is already in the options, it will not be added again. If class specification at given options
     * is an array, and some class placed there with the named (string) key, overriding of such key will have no
     * effect. For example:
     *
     * ```php
     * $options = ['class' => ['persistent' => 'initial']];
     *
     * // ['class' => ['persistent' => 'initial']];
     * Html::addCssClass($options, ['persistent' => 'override']);
     * ```
     *
     * @see removeCssClass()
     *
     * @param array $options The options to be modified.
     * @param string|string[] $class The CSS class(es) to be added.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function addCssClass(array &$options, $class): void
    {
        if (isset($options['class'])) {
            if (is_array($options['class'])) {
                $options['class'] = self::mergeCssClasses($options['class'], (array)$class);
            } else {
                $classes = preg_split('/\s+/', $options['class'], -1, PREG_SPLIT_NO_EMPTY);
                $options['class'] = implode(' ', self::mergeCssClasses($classes, (array)$class));
            }
        } else {
            $options['class'] = $class;
        }
    }

    /**
     * Removes a CSS class from the specified options.
     *
     * @see addCssClass()
     *
     * @param array $options The options to be modified.
     * @param string|string[] $class The CSS class(es) to be removed.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function removeCssClass(array &$options, $class): void
    {
        if (isset($options['class'])) {
            if (is_array($options['class'])) {
                $classes = array_diff($options['class'], (array)$class);
                if (empty($classes)) {
                    unset($options['class']);
                } else {
                    $options['class'] = $classes;
                }
            } else {
                $classes = preg_split('/\s+/', $options['class'], -1, PREG_SPLIT_NO_EMPTY);
                $classes = array_diff($classes, (array)$class);
                if (empty($classes)) {
                    unset($options['class']);
                } else {
                    $options['class'] = implode(' ', $classes);
                }
            }
        }
        /** @psalm-var HtmlOptions $options */
    }

    /**
     * Merges already existing CSS classes with new one.
     *
     * This method provides the priority for named existing classes over additional.
     *
     * @param string[] $existingClasses Already existing CSS classes.
     * @param string[] $additionalClasses CSS classes to be added.
     *
     * @return string[] merge result.
     */
    private static function mergeCssClasses(array $existingClasses, array $additionalClasses): array
    {
        foreach ($additionalClasses as $key => $class) {
            if (is_int($key) && !in_array($class, $existingClasses, true)) {
                $existingClasses[] = $class;
            } elseif (!isset($existingClasses[$key])) {
                $existingClasses[$key] = $class;
            }
        }

        return array_unique($existingClasses);
    }

    /**
     * Adds the specified CSS style to the HTML options.
     *
     * If the options already contain a `style` element, the new style will be merged
     * with the existing one. If a CSS property exists in both the new and the old styles,
     * the old one may be overwritten if `$overwrite` is true.
     *
     * For example,
     *
     * ```php
     * Html::addCssStyle($options, 'width: 100px; height: 200px');
     * ```
     *
     * @see removeCssStyle()
     *
     * @param array $options The HTML options to be modified.
     * @param array<string, string>|string $style The new style string (e.g. `'width: 100px; height: 200px'`) or array
     * (e.g. `['width' => '100px', 'height' => '200px']`).
     * @param bool $overwrite Whether to overwrite existing CSS properties if the new style contain them too.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function addCssStyle(array &$options, $style, bool $overwrite = true): void
    {
        if (!empty($options['style'])) {
            $oldStyle = is_array($options['style']) ? $options['style'] : self::cssStyleToArray($options['style']);
            $newStyle = is_array($style) ? $style : self::cssStyleToArray($style);
            if (!$overwrite) {
                foreach ($newStyle as $property => $value) {
                    if (isset($oldStyle[$property])) {
                        unset($newStyle[$property]);
                    }
                }
            }
            $style = array_merge($oldStyle, $newStyle);
        }
        $options['style'] = is_array($style) ? self::cssStyleFromArray($style) : $style;
    }

    /**
     * Removes the specified CSS style from the HTML options.
     *
     * For example,
     *
     * ```php
     * Html::removeCssStyle($options, ['width', 'height']);
     * ```
     *
     * @see addCssStyle()
     *
     * @param array $options The HTML options to be modified.
     * @param string|string[] $properties The CSS properties to be removed. You may use a string if you are removing a
     * single property.
     *
     * @psalm-param HtmlOptions $options
     */
    public static function removeCssStyle(array &$options, $properties): void
    {
        if (!empty($options['style'])) {
            $style = is_array($options['style']) ? $options['style'] : self::cssStyleToArray($options['style']);
            foreach ((array)$properties as $property) {
                unset($style[$property]);
            }
            $options['style'] = self::cssStyleFromArray($style);
        }
    }

    /**
     * Converts a CSS style array into a string representation.
     *
     * For example,
     *
     * ```php
     * // width: 100px; height: 200px;
     * Html::cssStyleFromArray(['width' => '100px', 'height' => '200px']);
     * ```
     *
     * @see cssStyleToArray()
     *
     * @param array<string, string> $style The CSS style array. The array keys are the CSS property names,
     * and the array values are the corresponding CSS property values.
     *
     * @return string|null The CSS style string. If the CSS style is empty, a null will be returned.
     */
    public static function cssStyleFromArray(array $style): ?string
    {
        $result = '';
        foreach ($style as $name => $value) {
            $result .= "$name: $value; ";
        }

        // Return null if empty to avoid rendering the "style" attribute.
        return $result === '' ? null : rtrim($result);
    }

    /**
     * Converts a CSS style string into an array representation.
     *
     * The array keys are the CSS property names, and the array values are the corresponding CSS property values.
     *
     * For example,
     *
     * ```php
     * // ['width' => '100px', 'height' => '200px']
     * Html::cssStyleToArray('width: 100px; height: 200px;');
     * ```
     *
     * @see cssStyleFromArray()
     *
     * @param string $style The CSS style string.
     *
     * @return array The array representation of the CSS style.
     * @psalm-return array<string, string>
     */
    public static function cssStyleToArray(string $style): array
    {
        $result = [];
        foreach (explode(';', $style) as $property) {
            $property = explode(':', $property);
            if (count($property) > 1) {
                $result[trim($property[0])] = trim($property[1]);
            }
        }

        return $result;
    }

    /**
     * Normalize PCRE regular expression to use in the "pattern" HTML attribute:
     *  - convert \x{FFFF} to \uFFFF;
     *  - remove flags and delimiters.
     *
     * For example:
     *
     * ```php
     * Html::normalizeRegexpPattern('/([a-z0-9-]+)/im'); // will return: ([a-z0-9-]+)
     * ```
     *
     * @see https://html.spec.whatwg.org/multipage/input.html#the-pattern-attribute
     *
     * @param string $regexp PCRE regular expression.
     * @param string|null $delimiter Regular expression delimiter.
     *
     * @throws InvalidArgumentException if incorrect regular expression or delimiter
     *
     * @return string Value for use in the "pattern" HTML attribute
     */
    public static function normalizeRegexpPattern(string $regexp, ?string $delimiter = null): string
    {
        if (strlen($regexp) < 2) {
            throw new InvalidArgumentException('Incorrect regular expression.');
        }

        $pattern = preg_replace('/\\\\x{?([0-9a-fA-F]+)}?/', '\u$1', $regexp);

        if ($delimiter === null) {
            $delimiter = substr($pattern, 0, 1);
        } elseif (strlen($delimiter) !== 1) {
            throw new InvalidArgumentException('Incorrect delimiter.');
        }

        try {
            $endPosition = strrpos($pattern, $delimiter, 1);
        } catch (ValueError $e) { // For PHP 8
            $endPosition = false;
        }
        if ($endPosition === false) {
            throw new InvalidArgumentException('Incorrect regular expression.');
        }

        return substr($pattern, 1, $endPosition - 1);
    }

    private static function getArrayableName(string $name): string
    {
        return substr($name, -2) !== '[]' ? $name . '[]' : $name;
    }

    private static function getNonArrayableName(string $name): string
    {
        return substr($name, -2) === '[]' ? substr($name, 0, -2) : $name;
    }
}
